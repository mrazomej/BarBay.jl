<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>vi · BarBay</title><meta name="title" content="vi · BarBay"/><meta property="og:title" content="vi · BarBay"/><meta property="twitter:title" content="vi · BarBay"/><meta name="description" content="Documentation for BarBay."/><meta property="og:description" content="Documentation for BarBay."/><meta property="twitter:description" content="Documentation for BarBay."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="BarBay logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">BarBay</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">BarBay</a></li><li><a class="tocitem" href="../contributing/">contributing</a></li><li><a class="tocitem" href="../examples/">examples</a></li><li><a class="tocitem" href="../math/">math</a></li><li><a class="tocitem" href="../mcmc/">mcmc</a></li><li><a class="tocitem" href="../model/">model</a></li><li><a class="tocitem" href="../stats/">stats</a></li><li><a class="tocitem" href="../utils/">utils</a></li><li class="is-active"><a class="tocitem" href>vi</a><ul class="internal"><li><a class="tocitem" href="#Primer-on-Variational-Inference"><span>Primer on Variational Inference</span></a></li><li><a class="tocitem" href="#vi-module"><span>vi module</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>vi</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>vi</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/mrazomej/BarBay.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/mrazomej/BarBay.jl/blob/main/docs/src/vi.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="vi"><a class="docs-heading-anchor" href="#vi">vi</a><a id="vi-1"></a><a class="docs-heading-anchor-permalink" href="#vi" title="Permalink"></a></h1><h2 id="Primer-on-Variational-Inference"><a class="docs-heading-anchor" href="#Primer-on-Variational-Inference">Primer on Variational Inference</a><a id="Primer-on-Variational-Inference-1"></a><a class="docs-heading-anchor-permalink" href="#Primer-on-Variational-Inference" title="Permalink"></a></h2><p>In this section, we will briefly introduce the idea behind variational inference. Recall that any Bayesian inference problem deals with the joint distribution between observations <span>$\underline{x}$</span> and unobserved latent variables <span>$\underline{\theta}$</span>. This joint distribution can be written as the product of a distribution of the observations <span>$\underline{x}$</span> conditioned on the <span>$\underline{\theta}$</span> and the marginal distribution of these latent variables, i.e.,</p><p class="math-container">\[\pi(\underline{x}, \underline{\theta}) =
\pi(\underline{x} \mid \underline{\theta}) \pi(\underline{\theta}).
\tag{1}\]</p><p>A Bayesian inference pipeline&#39;s objective is to compute the latent variables&#39; posterior probability given a set of observations. This computation is equivalent to updating our prior beliefs about the set of values that the latent variables take after taking in new data. We write this as Bayes theorem</p><p class="math-container">\[\pi(\underline{\theta} \mid \underline{x}) = 
\frac{
        \pi(\underline{x} \mid \underline{\theta})\pi(\underline{\theta})
    }{
        \pi(\underline{x})
    }.
\tag{2}\]</p><p>The main technical challenge for working with Eq. 2 comes from the computation of the denominator, also known as the <em>evidence</em> or the <em>marginalized likelihood</em>. The reason computing this term is challenging is because it involves a (potentially) high-dimensional integral of the form</p><p class="math-container">\[\pi(\underline{x}) = 
\int\cdots\int d^K\underline{\theta}\; \pi(\underline{x}, \underline{\theta}) = 
\int\cdots\int d^K\underline{\theta}\; \pi(\underline{x} \mid \underline{\theta})
\pi(\underline{\theta}),
\tag{3}\]</p><p>where <span>$K$</span> is the dimesionality of the <span>$\underline{\theta}$</span> vector. Here, the integrals are taken over the support–-the set of values valid for the distribution–-of <span>$\pi(\underline{\theta})$</span>. However, only a few selected distributions have a closed analytical form; thus, in most cases Eq. 3 must be solved numerically.</p><p>Integration in high-dimensional spaces can be computationally extremely challenging. For a naive numerical quadrature procedure, integrating over a grid of values for each dimension of <span>$\underline{\theta}$</span> comes with an exponential explosion of the number of required grid point evaluations, most of which do not contribute significantly to the integration. To gain visual intuition about this challenge, imagine integrating the function depicted in fig-SI01. If the location of the high-density region (dark peak) is unknown, numerical quadrature requires many grid points to ensure we capture this peak. However, most of the numerical evaluations of the function on the grid points do not contribute significantly to the integral. Therefore, our computational resources are wasted on insignificant evaluations. This only gets worse as the number of dimensions increases since the number of grid point evaluation scales exponentially.</p><p>Modern Markov Chain Monte Carlo algorithms, such as Hamiltonian Monte Carlo, can efficiently perform this high-dimensional integration by utilizing gradient information from the target density betancourt2017. Nevertheless, these sampling-based methods become prohibitively slow for the number of dimensions our present inference problem presents. Thus, there is a need to find scalable methods for the inference problem in Eq. 2.</p><p>Variational inference circumvents these technical challenges by proposing an approximate solution to the problem. Instead of working with the posterior distribution in its full glory <span>$\pi(\underline{\theta} \mid \underline{x})$</span>, let us propose an approximate posterior distribution <span>$q_\phi$</span> that belongs to a distribution family fully parametrized by <span>$\phi$</span>. For example, let us say that the distribution <span>$q_\phi$</span> belongs to the family of multivariate Normal distributions such that <span>$\phi = (\underline{\mu}, \underline{\underline{\Sigma}})$</span>, where <span>$\underline{\mu}$</span> is the vector of means and <span>$\underline{\underline{\Sigma}}$</span> is the covariance matrix. If we replace <span>$\pi$</span> by <span>$q_\phi$</span>, we want <span>$q_\phi$</span> to resemble the original posterior as much as possible. Mathematically, this can be expressed as minimizing a &quot;<em>distance metric</em>&quot;–-the Kullback-Leibler (KL) divergence, for example–-between the distributions. Note that we use quotation marks because, formally, the KL divergence is not a distance metric since it is not symmetric. Nevertheless, the variational objective is set to find a distribution <span>$q_\phi^*$</span> such that</p><p class="math-container">\[q_\phi^*(\underline{\theta}) =
\min_\phi D_{KL}\left(
    q_\phi(\underline{\theta}) \vert\vert 
    \pi(\underline{\theta} \mid \underline{x})
\right),
\tag{4}\]</p><p>where <span>$D_{KL}$</span> is the KL divergence. Furthermore, we highlight that the KL divergence is a strictly positive number, i.e.,</p><p class="math-container">\[D_{KL}\left(
    q_\phi(\underline{\theta}) \vert\vert 
    \pi(\underline{\theta} \mid \underline{x})
\right) \geq 0,
\tag{5}\]</p><p>as this property will become important later on.</p><p>At first sight, Eq. 4 does not improve the situation but only introduces further technical complications. After all, the definition of the KL divergence</p><p class="math-container">\[D_{KL}\left(
    q_\phi(\underline{\theta}) \vert\vert 
    \pi(\underline{\theta} \mid \underline{x})
\right) \equiv 
\int \cdots \int d^K\underline{\theta}\;
q_\phi(\underline{\theta})
\ln \frac{
    q_\phi(\underline{\theta})
}{
    \pi(\underline{\theta} \mid \underline{x})
},
\tag{6}\]</p><p>includes the posterior distribution <span>$\pi(\underline{\theta} \mid \underline{x})$</span> we are trying to get around. However, let us manipulate Eq. 6 to beat it to a more reasonable form. First, we can use the properties of the logarithms to write</p><p class="math-container">\[D_{KL}\left(
    q_\phi(\underline{\theta}) \vert\vert 
    \pi(\underline{\theta} \mid \underline{x})
\right) = 
\int d^K\underline{\theta}\; q_\phi(\underline{\theta})
\ln q_\phi(\underline{\theta}) -
\int d^K\underline{\theta}\; q_\phi(\underline{\theta})
\ln \pi(\underline{\theta} \mid \underline{x}),
\tag{7}\]</p><p>where, for convenience, we write a single integration sign (<span>$d^K\underline{\theta}\;$</span> still represents a multi-dimensional differential). For the second term in Eq. 7, we can substitute the term inside the logarithm using Eq. 2. This results in</p><p class="math-container">\[\begin{aligned}
D_{KL}\left(
    q_\phi(\underline{\theta}) \vert\vert 
    \pi(\underline{\theta} \mid \underline{x})
\right) &amp;= 
\int d^K\underline{\theta}\; q_\phi(\underline{\theta})
\ln q_\phi(\underline{\theta}) \\
&amp;- \int d^K\underline{\theta}\; q_\phi(\underline{\theta})
\ln \left( 
    \frac{
        \pi(\underline{x} \mid \underline{\theta})\pi(\underline{\theta})
    }{
        \pi(\underline{x})
    }
\right).
\end{aligned}
\tag{8}\]</p><p>Again, using the properties of logarithms, we can split Eq. 8, obtaining</p><p class="math-container">\[\begin{aligned}
D_{KL}\left(
    q_\phi(\underline{\theta}) \vert\vert 
    \pi(\underline{\theta} \mid \underline{x})
\right) &amp;= 
\int d^K\underline{\theta}\; q_\phi(\underline{\theta})
\ln q_\phi(\underline{\theta}) \\
&amp;-\int d^K\underline{\theta}\; q_\phi(\underline{\theta})
\ln \pi(\underline{x} \mid \underline{\theta}) \\
&amp;-\int d^K\underline{\theta}\; q_\phi(\underline{\theta})
\ln \pi(\underline{\theta}) \\
&amp;+\int d^K\underline{\theta}\; q_\phi(\underline{\theta})
\ln \pi(\underline{x}).
\end{aligned}
\tag{9}\]</p><p>It is convenient to write Eq. 9 as</p><p class="math-container">\[\begin{aligned}
D_{KL}\left(
    q_\phi(\underline{\theta}) \vert\vert 
    \pi(\underline{\theta} \mid \underline{x})
\right) &amp;= 
\int d^K\underline{\theta}\; q_\phi(\underline{\theta})
\ln \frac{
    q_\phi(\underline{\theta})
    }{
        \pi(\underline{\theta})
    } \\
&amp;-\int d^K\underline{\theta}\; q_\phi(\underline{\theta})
\ln \pi(\underline{x} \mid \underline{\theta}) \\
&amp;+ \ln \pi(\underline{x}) 
\int d^K\underline{\theta}\; q_\phi(\underline{\theta}),
\end{aligned}
\tag{10}\]</p><p>where for the last term, we can take <span>$\ln \pi(\underline{x})$</span> out of the integral since it does not depend on <span>$\underline{\theta}$</span>. Lastly, we utilize two properties:</p><ul><li>The proposed approximate distribution must be normalized, i.e.,</li></ul><p class="math-container">\[\int d^K\underline{\theta}\; q_\phi(\underline{\theta}) = 1.
\tag{11}\]</p><ul><li>The law of the unconscious statistician (LOTUS) establishes that for any</li></ul><p>probability density function, it must be true that</p><p class="math-container">\[\int d^K\underline{\theta}\; q_\phi(\underline{\theta})
f(\underline{\theta}) = \left\langle 
    f(\underline{\theta}) 
\right\rangle_{q_\phi},
\tag{12}\]</p><p>where <span>$\left\langle\cdot\right\rangle_{q_\phi}$</span> is the expected value over the <span>$q_\phi$</span> distribution.</p><p>Using these two properties, the positivity constraint on the KL divergence in Eq. 5, and the definition of the KL divergence in Eq. 6 we can rewrite Eq. 10 as</p><p class="math-container">\[D_{KL}\left( 
    q_\phi(\underline{\theta}) \vert \vert
    \pi(\underline{\theta}) 
\right) -
\left\langle
    \ln \pi(\underline{x} \mid \underline{\theta})
\right\rangle_{q_\phi}
\geq - \ln \pi(\underline{x}).
\tag{13}\]</p><p>Multiplying by a minus one, we have the functional form of the so-called evidence lower bound (ELBO) kingma2014,</p><p class="math-container">\[\underbrace{
    \ln \pi(\underline{x})
}_{\text{log evidence}} \geq
\underbrace{
    \left\langle
        \ln \pi(\underline{x} \mid \underline{\theta})
    \right\rangle_{q_\phi} -
    D_{KL}\left( 
        q_\phi(\underline{\theta}) \vert \vert
        \pi(\underline{\theta}) 
    \right)
}_{\text{ELBO}}.
\tag{14}\]</p><p>Let us recapitulate where we are. We started by presenting the challenge of working with Bayes&#39; theorem, as it requires a high-dimensional integral of the form in Eq. 3. As an alternative, variational inference posits to approximate the posterior distribution <span>$\pi(\underline{\theta} \mid \underline{x})$</span> with a parametric distribution <span>$q_\phi(\underline{\theta})$</span>. By minimizing the KL divergence between these distributions, we arrive at the result in Eq. 14, where the left-hand side–-the log marginalized likelihood or log evidence–-we cannot compute for technical/computational reasons. However, the right-hand side is composed of things we can easily evaluate. We can easily evaluate the log-likelihood <span>$\ln \pi(\underline{x} \mid \underline{\theta})$</span> and the KL divergence between our proposed approximate distribution <span>$q_\phi(\underline{\theta})$</span> and the prior distribution <span>$\pi(\underline{\theta})$</span>. Moreover, we can compute the gradients of these functions with respect to the parameters of our proposed distribution. This last point implies that we can change the parameters of the proposed distribution to maximize the ELBO. And, although we cannot compute the left-hand side of Eq. 14, we know that however large we make the ELBO, it will always be smaller than (or equal) the log-marginal likelihood. Therefore, the larger we can make the ELBO by modifying the parameters <span>$\phi$</span>, the closer it gets to the log-marginal likelihood, and, as a consequence, the better our proposed distribution <span>$q_\phi(\underline{\theta})$</span> gets to the true posterior distribution <span>$\pi(\underline{\theta} \mid \underline{x})$</span>.</p><p>In this sense, variational inference turns the intractable numerical integration problem to an optimization routine, for which there are several algorithms  available.</p><h3 id="ADVI-algorithm"><a class="docs-heading-anchor" href="#ADVI-algorithm">ADVI algorithm</a><a id="ADVI-algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#ADVI-algorithm" title="Permalink"></a></h3><p>To maximize the right-hand side of Eq. 14, the Automatic Differentiation Variational Inference (ADVI) algorithm developed in [kucukelbir2016] takes advantage of advances in probabilistic programming languages to generate a robust method to perform this optimization. Without going into the details of the algorithm implementation, for our purposes, it suffices to say that we define our joint distribution <span>$\pi(\underline{\theta}, \underline{x})$</span> as the product defined in Eq. 1. ADVI then proposes an approximate variational distribution <span>$q_\phi$</span> that can either be a multivariate Normal distribution with a diagonal covariance matrix, i.e.,</p><p class="math-container">\[\phi = (\underline{\mu}, \underline{\underline{D}}),
\tag{15}\]</p><p>where <span>$\underline{\underline{D}}$</span> is the identity matrix, with the diagonal elements given by the vector of variances <span>$\underline{\sigma}^2$</span> for each variable or a full-rank multivariate Normal distribution</p><p class="math-container">\[\phi = (\underline{\mu}, \underline{\underline{\Sigma}}).
\tag{16}\]</p><p>Then, the parameters are initialized in some value <span>$\phi_o$</span>. These parameters are iteratively updated by computing the gradient of the ELBO (right-hand side of Eq. 14), hereafter defined as <span>$\mathcal{L}$</span>, with respect to the parameters, </p><p class="math-container">\[\nabla_\phi \mathcal{L} = \nabla_{\underline{\mu}} \mathcal{L} + 
\nabla_{\underline{\sigma}}\mathcal{L},
\tag{17}\]</p><p>and then computing</p><p class="math-container">\[\phi_{t+1} = \phi_{t} + \eta \nabla_\phi \mathcal{L},
\tag{18}\]</p><p>where <span>$\eta$</span> defines the step size.</p><p>This short explanation behind the ADVI algorithm is intended only to gain intuition on how the optimal variational distribution <span>$q_\phi$</span> be computed. There are many nuances in the implementation of the ADVI algorithm. We invite the user to look at the original reference for further details.</p><h2 id="vi-module"><a class="docs-heading-anchor" href="#vi-module">vi module</a><a id="vi-module-1"></a><a class="docs-heading-anchor-permalink" href="#vi-module" title="Permalink"></a></h2><p>This <code>vi</code> module includes (so far) a single function to run variational  inference using the ADVI algorithm implemented in <code>Turing.jl</code>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BarBay.vi.advi-Tuple{}" href="#BarBay.vi.advi-Tuple{}"><code>BarBay.vi.advi</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">advi(; kwargs)</code></pre><p>Run Automatic Differentiation Variational Inference (ADVI) to sample the joint posterior distribution for the fitness value of all mutant and neutral lineages given a time-series barcode count data.</p><p>This function expects the data in a <strong>tidy</strong> format. Each row should represent <strong>a single observation</strong>. For instance, if barcode <code>i</code> is measured at 4 different time points, each of these measurements would have its own row. The same applies to barcode <code>j</code> and its measurements.</p><p>The <code>DataFrame</code> must contain at least the following columns, specified by their respective keyword arguments:</p><ul><li><code>id_col</code>: Identifies the barcode ID (e.g., barcode sequence).</li><li><code>time_col</code>: Indicates the measurement time point.</li><li><code>count_col</code>: Contains the raw barcode count.</li><li><code>neutral_col</code>: Indicates if the barcode is from a neutral lineage. Additional</li></ul><p>optional columns include <code>rep_col</code>, <code>env_col</code>, and <code>genotype_col</code>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>data::DF.AbstractDataFrame</code>: Tidy dataframe with data for sampling the population mean fitness posterior distribution.</li><li><code>outputname::Union{String,Nothing}</code>: Name for the output <code>.csv</code> file (default is <code>nothing</code>).</li><li><code>model::Function</code>: <code>Turing.jl</code> model defining the posterior distribution.</li><li><code>model_kwargs::Dict=Dict()</code>: Extra keyword arguments for the <code>model</code> function.</li><li><code>id_col::Symbol=:barcode</code>: Column in <code>data</code> containing barcode identifiers.</li><li><code>time_col::Symbol=:time</code>: Column in <code>data</code> defining the time point of measurements.</li><li><code>count_col::Symbol=:count</code>: Column in <code>data</code> containing raw barcode counts.</li><li><code>neutral_col::Symbol=:neutral</code>: Column in <code>data</code> defining neutral lineage.</li><li><code>rep_col::Union{Nothing,Symbol}=nothing</code>: Column for experimental replicate.</li><li><code>env_col::Union{Nothing,Symbol}=nothing</code>: Column for environment.</li><li><code>genotype_col::Union{Nothing,Symbol}=nothing</code>: Column for genotype.</li><li><code>rm_T0::Bool=false</code>: Option to remove the first time point from inference.</li><li><code>advi::Turing.AdvancedVI.VariationalInference=Turing.ADVI{Turing.AutoReverseDiff(true)}(1,   10_000)</code>, A default instance of <code>Turing.AdvancedVI.VariationalInference</code>   with the following parameters:<ul><li><code>Turing.ADVI{AD}</code>: The variational inference algorithm used with automatic differentiation algorithm <code>AD</code>. Default is <code>Turing.AutoReverseDiff(true)</code>, meaning reverse-mode AD is used with compiled tape for random number generation.</li><li><code>(samples_per_step::Int64, max_iters::Int64)</code>: Number of samples used to estimate the ELBO in each optimization step, and Maximum number of gradient steps. Default is <code>(1, 10_000)</code>.</li></ul></li><li><code>opt::Union{Turing.AdvancedVI.TruncatedADAGrad,Turing.AdvancedVI.DecayedADAGrad}=Turing.Variational.TruncatedADAGrad()</code>: Gradient computation and parameter update algorithm. Default is <code>Turing.Variational.TruncatedADAGrad()</code>.</li><li><code>verbose::Bool=true</code>: Flag for printing progress updates. Default is <code>true</code>.</li></ul><p><strong>Returns</strong></p><ul><li>If <code>outputname</code> is <code>nothing</code>, returns a <code>DataFrames.DataFrame</code> containing summary statistics of posterior samples for each parameter.</li><li>If <code>outputname</code> is specified, saves the results to a CSV file and does not return a DataFrame.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mrazomej/BarBay.jl/blob/3c9a2740f7e5c7fcbffe3a5a4fe7ca59b17902c5/src/vi.jl#L19-L75">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../utils/">« utils</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Thursday 28 December 2023 20:54">Thursday 28 December 2023</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
